diff --git a/controller-server/index.ts b/controller-server/index.ts
index 8ef432e..0eb47aa 100644
--- a/controller-server/index.ts
+++ b/controller-server/index.ts
@@ -9,6 +9,8 @@ import createNTPServer from "@/ntp";
 
 import { handleOnRPiMessage, handleOnControlPanelMessage } from "@/websocket";
 import { Message } from "@/types/global";
+import { ToRPiSync } from "@/types/RPiMessage";
+import { sendBeatToRPi } from "@/websocket/RPi/handlers";
 
 const { SERVER_HOSTNAME, SERVER_PORT, NTPSERVER_PORT } = process.env;
 
@@ -57,6 +59,16 @@ wss.on("connection", function connection(ws: WebSocket) {
   ws.on("error", console.error);
 });
 
+setInterval(() => {
+  const toRPiMsg: ToRPiSync = {
+    from: "server",
+    topic: "sync",
+    statusCode: 0,
+    payload: "",
+  };
+  sendBeatToRPi(["0_hjko", "1_sauby", "2_adam"], toRPiMsg);
+}, 5000);
+
 createNTPServer(parseInt(NTPSERVER_PORT));
 
 server.listen(SERVER_PORT, () => {
diff --git a/controller-server/websocket/RPi/handlers.ts b/controller-server/websocket/RPi/handlers.ts
index be70d04..1f364dc 100644
--- a/controller-server/websocket/RPi/handlers.ts
+++ b/controller-server/websocket/RPi/handlers.ts
@@ -45,19 +45,59 @@ export function sendToRPi(dancers: string[], msg: ToRPi) {
           sendBoardInfoToControlPanel();
           continue;
         }
-
         RPiWSs[MAC].send(toSend);
       } else {
         dancerTable[MAC].connected = false;
         sendBoardInfoToControlPanel();
       }
     }
-
     // when both wifi and ethernet are not connected
     console.error(`[Error]: RPi not connected! ${dancer}`);
   });
 }
 
+export function sendBeatToRPi(dancers: string[], msg: ToRPi) {
+  console.log("[Send Beat]: RPi", msg, dancers, "\n");
+  const toSend = JSON.stringify({
+    ...msg,
+    ...(msg.topic === "command" && { payload: msg.payload.join(" ") }),
+  });
+  var update: boolean = false;
+  dancers.forEach((dancer: string) => {
+    if (!(dancer in dancerToMAC)) {
+      console.error(`[Error]: dancer not found! ${dancer}`);
+      return;
+    }
+
+    const { wifi, ethernet } = dancerToMAC[dancer];
+
+    for (const MAC of [ethernet, wifi]) {
+      if (MAC in RPiWSs) {
+        if (RPiWSs[MAC].readyState !== WebSocket.OPEN) {
+          console.error(
+            `[Error]: Dancer: ${dancer} Websocket closed on MAC: ${MAC}`
+          );
+          delete RPiWSs[MAC];
+          if (dancerTable[MAC].connected) update = true;
+          dancerTable[MAC].connected = false;
+          continue;
+        }
+        console.log(
+          `Successfully send message to MAC: ${MAC} on dancer: ${dancer}`
+        );
+        RPiWSs[MAC].send(toSend);
+      } else {
+        console.error(
+          `[Error]: Dancer: ${dancer} No RPi connect to MAC: ${MAC}`
+        );
+        if (dancerTable[MAC].connected) update = true;
+        dancerTable[MAC].connected = false;
+      }
+    }
+  });
+  if (update) sendBoardInfoToControlPanel();
+}
+
 export async function sendBoardInfoToRPi(dancer: string) {
   // send pinMap, LED and OF to RPi
   const [LEDresult, OFresult] = await Promise.allSettled([
@@ -122,6 +162,31 @@ export async function handleRPiBoardInfo(ws: WebSocket, msg: FromRPiBoardInfo) {
     delete RPiWSs[MAC];
     sendBoardInfoToControlPanel();
   });
+
+  setupTimeoutCheck(ws, MAC);
+}
+
+function setupTimeoutCheck(ws: WebSocket, MAC: string) {
+  let timeout = setTimeout(() => {
+    console.warn(`[Timeout]: RPi ${MAC} 可能已斷線`);
+    dancerTable[MAC].connected = false;
+    delete RPiWSs[MAC];
+    sendBoardInfoToControlPanel();
+  }, 6000);
+
+  ws.on("message", () => {
+    clearTimeout(timeout);
+    timeout = setTimeout(() => {
+      console.warn(`[Timeout]: RPi ${MAC} 可能已斷線`);
+      dancerTable[MAC].connected = false;
+      delete RPiWSs[MAC];
+      sendBoardInfoToControlPanel();
+    }, 6000);
+  });
+
+  ws.on("close", () => {
+    clearTimeout(timeout);
+  });
 }
 
 export function handleRPiCommandResponse(
@@ -143,7 +208,6 @@ export function handleRPiCommandResponse(
       message,
     },
   };
-
   sendToControlPanel(toControlPanelMsg);
 }
 
